# BCJR Trellis Builder (McEliece–A)

Проект строит BCJR-trellis (рёбра между состояниями `E(i-1, i)`) для линейного кода на основе пораждающей матрицы, используя представление McEliece–A (MSGM) и дальнейшее построение таблиц `init`, `fin`, `lambda` для каждого шага.

## Ввод / формат файла

Файл содержит:
- `k n` — число строк и число столбцов (битов)
- далее `k` строк длины `n` из `0/1` — матрица

Пример:
```
3 8
10011001
01001010
00111100
```

## Сборка и Запуск

```bash
make
./project <filename>
```

Программа печатает для каждого i = 1..n ребро E(i-1, i) и таблицы:
	•	u — все бинарные наборы для переменных на шаге i
	•	init(u) — проекция на “пришедшие” переменные (из прошлого шага)
	•	fin(u) — проекция на “уходящие” переменные (в следующий шаг)
	•	lambda(u) — проверка ограничения (паритет) для шага i

Основные структуры данных

## 1. Хранение матрицы битов блоками

Тип: `std::vector<std::vector<uint64_t>> matrix`

Матрица хранится построчно, но каждая строка упакована в блоки по `64` бита:
	•	один `uint64_t = 64` бита
	•	размер блока задаётся `Matrix::BLOCK_SIZE = 64`

Это даёт:
	•	компактность
	•	быстрые операции XOR над строками (линейные преобразования): `matrix[v2][i] ^= matrix[v1][i]`

Преобразование строки из файла делается через:
	•	`str_to_ui64_block(line, start) — формирует 64-битный блок из подстроки line[start..start+63]`

## 2. Интервалы активности строки (span)

Тип: `std::vector<std::pair<int,int>> span`

Для каждой строки хранится пара `(l, r)`:
	•	`l` — индекс первого 1 в строке
	•	`r` — индекс последнего 1 в строке
	•	пустая строка кодируется как `(-1, -1)`

Обновление: `update_span(ind)`
	•	сначала ищется первый установленный бит слева
	•	затем последний установленный бит справа

Важно: span хранится как `pair<int,int>`, а не `size_t`, потому что нужен маркер -1.

## 3. Приведение к `MSGM` (McEliece–A форма)

Функция: `to_msgm()`

Идея: итеративно устраняются совпадения границ span у разных строк:
	•	если `span[i].first == span[j].first` — XOR “короткой” в “длинную”
	•	если `span[i].second == span[j].second` — аналогично по правой границе

Операция сложения строк:
	•	add_rows(v1, v2) делает XOR блоков и обновляет span второй строки

## 4. Выделение базиса (удаление нулевых строк)

Функция: `make_basis()`

Оставляются только строки с span != (-1,-1).

Структуры для построения `BCJR-trellis`

После `MSGM` + базиса строятся множества для каждого шага i (1..n).

## 5. Множество активных строк на шаге `i`

Тип: `std::vector<std::vector<uint32_t>> a` размера `n+1`

`uint32_t`: индексы строк невелики, экономия памяти.

## 6. Множество активных строк на глубине i 

Тип: `std::vector<std::unordered_set<uint32_t>> b` размера `n+1`

`unordered_set`: быстро проверять принадлежность при построении `init/fin`.

## 7. Координаты (позиции) переменных из `a[i]`

Тип: `std::vector<std::vector<int32_t>> a_coord`

Размер: `(n+1) x (k+1)` и заполнение `-1`.

`a_coord[i][j]` — позиция (индекс) элемента `j` внутри `a[i]`.
Это нужно для того, чтобы быстро брать нужные биты из двоичной строки `u`.

## 8. Таблицы `init` и `fin`

Типы:
	•	`std::vector<std::vector<uint32_t>> init_`
	•	`std::vector<std::vector<uint32_t>> fin_`

Определения:
	•	`init_[i] = a[i] ∩ b[i-1]` — вершина из которой выходит ребро `i`
	•	`fin_[i]  = a[i] ∩ b[i]`   — вершина в которую направлено ребро `i`

## 9. Вектор `λ (lambda)` как строка битов `g_[i]`

Тип: `std::vector<std::string> g_` размера `n+1`

`g_[i]` — для каждого шага `i` хранит биты матрицы в столбце `i` только для активных строк `a[i]`
Это затем используется для вычисления:
	•	`lambda(u) = (u · g_[i]) mod 2`

Печать ребра `E(i-1, i)`

Функция: `print_edge(i)`

Шаги:
	1.	Генерируются все бинарные вектора u длины `|a[i]|`:
	•	`2^{|a[i]|}` вариантов
	2.	Для каждого u печатаются:
	•	`init(u)` — берутся компоненты u только по индексам `init_[i]`
	•	`fin(u)` — по индексам `fin_[i]`
	•	`lambda(u)` — сумма `u[t]*g_[i][t] mod 2`

Файлы
	•	main.cpp — CLI, чтение файла, вызовы:
	1.	Matrix(filename)
	2.	to_msgm()
	3.	make_basis()
	4.	create_tables()
	5.	печать print_edge(i) для всех i=1..n
	•	matrix.hpp / matrix.cpp — реализация хранения матрицы, MSGM, построение таблиц, печать ребра.
